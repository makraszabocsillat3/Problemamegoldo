<!DOCTYPE html>
<html lang="hu">
<head>
  <meta charset="utf-8" />
  <title>Beadand√≥ ‚Äì V√°lasztott feladatok ‚Äì Makra-Szab√≥ Csilla</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="style.css?v=6">
</head>
<body>
  <header class="topbar">
    <div class="wrap">
      <h1>Beadand√≥ ‚Äì V√°lasztott feladatok</h1>
      <p class="subtitle"><strong>Makra-Szab√≥ Csilla</strong> ‚Ä¢ ≈ëszi f√©l√©v ‚Ä¢ 4 beadand√≥</p>
    </div>
  </header>

  <main class="wrap">
    <section class="intro">
      <p>Az SZTE-TTIK ‚ÄûProbl√©mamegold√≥ szemin√°rium‚Äù kurzus beadand√≥ feladatainak gy≈±jt≈ëoldala.</p>

      <!-- √ñsszefoglal√≥ t√°bl√°zat -->
      <table>
        <thead>
          <tr><th>Feladat</th><th>T√©ma</th><th>Forr√°s</th></tr>
        </thead>
        <tbody>
          <tr>
            <td>Vesz√©lyes helyek</td>
            <td>Rekurzi√≥</td>
            <td><a href="http://tehetseg.inf.elte.hu/nemes-online/2024/fordulo1.pdf" target="_blank" rel="noopener">fordulo1.pdf (2024)</a></td>
          </tr>
          <tr>
            <td>F√∂ldv√°s√°rl√°s</td>
            <td>Dinamikus programoz√°s</td>
            <td><a href="http://tehetseg.inf.elte.hu/nemes-online/2022/nemeso1-22.pdf" target="_blank" rel="noopener">nemeso1-22.pdf (2022)</a></td>
          </tr>
          <tr>
            <td>Fi√∫k √©s l√°nyok 1</td>
            <td>Moh√≥ strat√©gia</td>
            <td><a href="http://tehetseg.inf.elte.hu/nemes-online/2024/fordulo1.pdf" target="_blank" rel="noopener">fordulo1.pdf (2024)</a></td>
          </tr>
          <tr>
            <td>T√°rsasj√°t√©k</td>
            <td>Gr√°falgoritmus</td>
            <td><a href="http://tehetseg.inf.elte.hu/nemes-online/2022/nemeso1-22.pdf" target="_blank" rel="noopener">nemeso1-22.pdf (2022)</a></td>
          </tr>
        </tbody>
      </table>
    </section>

    <section class="grid">

      <!-- 1. Vesz√©lyes helyek ‚Äî Rekurzi√≥ -->
      <article class="card">
        <div class="card-head">
          <h2 class="task-title"><span class="num">1</span> Beadand√≥ ‚Äî Vesz√©lyes helyek</h2>
        </div>
        <div class="topic">
          <span class="chip rekurzio">Rekurzi√≥</span>
        </div>

        <section class="block">
          <h3 class="label">Forr√°sfeladat</h3>
          <p class="line">
            üîó <a href="http://tehetseg.inf.elte.hu/nemes-online/2024/fordulo1.pdf" target="_blank" rel="noopener">
              Nemes Online 2024 ‚Äî 1. fordul√≥ (PDF)
            </a>
          </p>
        </section>

        <section class="block">
          <h3 class="label">Feladatsz√∂veg k√©pe</h3>
          <figure class="problem-fig">
            <img src="img/Veszelyes-helyek.png" alt="Vesz√©lyes helyek ‚Äì feladatsz√∂veg" class="problem-img">
            <figcaption>Vesz√©lyes helyek ‚Äî feladatsz√∂veg</figcaption>
          </figure>
        </section>

        <!-- VESZ√âLYES HELYEK ‚Äì MAGYAR√ÅZAT -->
        <section class="block">
          <h3 class="label">Magyar√°zat (sz√∂vegben)</h3>
          <pre class="explain">Vesz√©lyes helyek ‚Äì Magyar√°zat (Rekurzi√≥)

A foly√≥t egy r√°csk√©nt √°br√°zoljuk, ahol minden mez≈ëben egy sz√°m √°ll:

0: biztons√°gos v√≠z

1: √∂rv√©ny, vesz√©lyes v√≠z

A haj√≥ a bal sz√©ls≈ë oszlopb√≥l indulhat, b√°rmelyik sorb√≥l. Minden l√©p√©sben csak jobbra mehet: jobbra-fel, jobbra-egyenesen vagy jobbra-le. A c√©l: olyan kezd≈ësor kiv√°laszt√°sa, ahonnan indulva a jobb sz√©ls≈ë oszlopig eljutva a lehet≈ë legkevesebb 1-es mez≈ën kell √°thaladni. Ha t√∂bb megold√°s is ugyanolyan j√≥, a legfel√ºl l√©v≈ët v√°lasztjuk.

Ehhez egy rekurz√≠v f√ºggv√©nyt haszn√°lok: legjobbUtvonalInnen(sor, oszlop).

Ez megmondja, hogy ha az adott (sor, oszlop) mez≈ër≈ël indulok, mennyi a legkevesebb √∂sszes 1-es, am√≠g el√©rek a jobb sz√©lig, ha mindig a legjobb ir√°nyt v√°lasztom.

Alapeset: ha az utols√≥ oszlopban vagyunk, akkor innen nincs tov√°bb l√©p√©s, a f√ºggv√©ny egyszer≈±en visszaadja az aktu√°lis mez≈ë √©rt√©k√©t (0 vagy 1).

Rekurz√≠v eset: ha nem az utols√≥ oszlopban vagyunk, akkor megn√©zem, merre tudok menni: jobbra-fel, jobbra, jobbra-le. Ezekre a poz√≠ci√≥kra rekurz√≠van megh√≠vom a legjobbUtvonalInnen f√ºggv√©nyt, √©s a h√°rom k√∂z√ºl kiv√°lasztom a legkisebb √©rt√©ket. Az aktu√°lis mez≈ë √©rt√©k√©t (0 vagy 1) hozz√°adom ehhez, √≠gy megkapom, mennyibe ‚Äûker√ºl‚Äù innen a jobb partig az optim√°lis √∫t.

Hogy ne sz√°moljak feleslegesen sokszor ugyanazt, egy m√°sik t√°bl√°t is vezetek: megjegyzesTabla[sor][oszlop]. Kezdetben mindenhol ‚Äì1 van benne. Ha egyszer m√°r kisz√°moltam legjobbUtvonalInnen(sor, oszlop) √©rt√©k√©t, elt√°rolom ebben a t√°bl√°ban. Ha legk√∂zelebb ugyanerr≈ël a mez≈ër≈ël k√©rdezem, nem h√≠vom √∫jra a rekurzi√≥t, csak visszaolvasom a t√°rolt √©rt√©ket.

A megold√°shoz a bal sz√©ls≈ë oszlop √∂sszes sor√°ra megh√≠vom a f√ºggv√©nyt: legjobbUtvonalInnen(sor, 0). Ahol a legkisebb √©rt√©ket kapom, az lesz a legjobb kezd≈ësor. A feladat 1-t≈ël sz√°mozza a sorokat, ez√©rt a program a kiv√°lasztott sor index√©hez 1-et ad.</pre>
        </section>

        <section class="block">
          <h3 class="label">Megold√°s (Java)</h3>
          <pre><code>import java.util.Scanner;

public class veszelyesHelyek {

    static int sorokSzama;
    static int oszlopokSzama;
    static int[][] palya;
    static int[][] megjegyzesTabla;

    public static int legjobbUtvonalInnen(int sor, int oszlop) {

        if (oszlop == oszlopokSzama - 1) {
            return palya[sor][oszlop];
        }
        if (megjegyzesTabla[sor][oszlop] != -1) {
            return megjegyzesTabla[sor][oszlop];
        }

        int legjobbEddig = Integer.MAX_VALUE;

        if (sor &gt; 0) {
            int ertekFel = legjobbUtvonalInnen(sor - 1, oszlop + 1);
            legjobbEddig = Math.min(legjobbEddig, ertekFel);
        }

        int ertekKozep = legjobbUtvonalInnen(sor, oszlop + 1);
        legjobbEddig = Math.min(legjobbEddig, ertekKozep);

        if (sor &lt; sorokSzama - 1) {
            int ertekLe = legjobbUtvonalInnen(sor + 1, oszlop + 1);
            legjobbEddig = Math.min(legjobbEddig, ertekLe);
        }

        int vegsoErtek = palya[sor][oszlop] + legjobbEddig;
        megjegyzesTabla[sor][oszlop] = vegsoErtek;

        return vegsoErtek;
    }

    public static int melyikSorbolInduljunk() {
        int legkisebbVeszely = Integer.MAX_VALUE;
        int legjobbSor = 0;

        for (int sor = 0; sor &lt; sorokSzama; sor++) {
            int veszely = legjobbUtvonalInnen(sor, 0);

            if (veszely &lt; legkisebbVeszely) {
                legkisebbVeszely = veszely;
                legjobbSor = sor;
            }
        }

        return legjobbSor + 1;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        sorokSzama = sc.nextInt();
        oszlopokSzama = sc.nextInt();

        palya = new int[sorokSzama][oszlopokSzama];
        megjegyzesTabla = new int[sorokSzama][oszlopokSzama];

        for (int sor = 0; sor &lt; sorokSzama; sor++) {
            for (int oszlop = 0; oszlop &lt; oszlopokSzama; oszlop++) {
                megjegyzesTabla[sor][oszlop] = -1;
            }
        }

        for (int sor = 0; sor &lt; sorokSzama; sor++) {
            for (int oszlop = 0; oszlop &lt; oszlopokSzama; oszlop++) {
                palya[sor][oszlop] = sc.nextInt();
            }
        }

        System.out.println(melyikSorbolInduljunk());
    }
}</code></pre>
        </section>

        <section class="block">
          <h3 class="label">K√©sz k√≥d (ZIP)</h3>
          <a class="btn download" href="zip/VeszelyesHelyek.zip" download>‚¨á Let√∂lt√©s (feladat1-kod.zip)</a>
        </section>
      </article>

      <!-- 2. Fi√∫k √©s l√°nyok 1 ‚Äî Moh√≥ strat√©gia -->
      <article class="card">
        <div class="card-head">
          <h2 class="task-title"><span class="num">2</span> Beadand√≥ ‚Äî Fi√∫k √©s l√°nyok 1</h2>
        </div>
        <div class="topic">
          <span class="chip moho">Moh√≥ strat√©gia</span>
        </div>

        <section class="block">
          <h3 class="label">Forr√°sfeladat</h3>
          <p class="line">
            üîó <a href="http://tehetseg.inf.elte.hu/nemes-online/2024/fordulo1.pdf" target="_blank" rel="noopener">
              Nemes Online 2024 ‚Äî 1. fordul√≥ (PDF)
            </a>
          </p>
        </section>

        <section class="block">
          <h3 class="label">Feladatsz√∂veg k√©pe</h3>
          <figure class="problem-fig">
            <img src="img/Fiuk-es-lanyok.png" alt="Fi√∫k √©s l√°nyok 1 ‚Äì feladatsz√∂veg" class="problem-img">
            <figcaption>Fi√∫k √©s l√°nyok 1 ‚Äî feladatsz√∂veg</figcaption>
          </figure>
        </section>

        <!-- FI√öK √âS L√ÅNYOK ‚Äì MAGYAR√ÅZAT -->
        <section class="block">
          <h3 class="label">Magyar√°zat (sz√∂vegben)</h3>
          <pre class="explain">Fi√∫k √©s l√°nyok ‚Äì Magyar√°zat (Moh√≥)

A feladatban egy sorban √°ll√≥ csoportot kapunk, ahol N fi√∫ √©s N l√°ny van. A sort egy karakterl√°nc √≠rja le, ahol F = fi√∫, L = l√°ny. √ñsszesen 2N gyerek √°ll egym√°s mellett.

C√©l: √∫gy √°trendezni a sort, hogy felv√°ltva √°lljanak a gyerekek, vagyis:

F L F L F L ‚Ä¶ vagy

L F L F L F ‚Ä¶

Mindegy, hogy fi√∫val vagy l√°nnyal kezd√ºnk, a l√©nyeg, hogy felv√°ltva k√∂vess√©k egym√°st. Egy l√©p√©sben egy fi√∫t √©s egy l√°nyt cser√©lhet√ºnk meg a sorban. A feladat azt k√©rdezi, hogy mi a minim√°lisan sz√ºks√©ges cser√©k sz√°ma.

A gondolatmenet:

K√©t lehets√©ges ‚Äûj√≥‚Äù mint√°t vizsg√°lok:

F-lel kezdj√ºk a sort: F L F L F L ‚Ä¶

L-lel kezdj√ºk a sort: L F L F L F ‚Ä¶

A program nem konkr√©t gyerekeket, hanem poz√≠ci√≥kat vizsg√°l. Minden poz√≠ci√≥n√°l tudjuk, hogy az adott mint√°ban melyik bet≈±nek kellene ott √°llnia. Ha a val√≥s sorban m√°s bet≈± √°ll ott, mint amit a minta szerint v√°rn√°nk, akkor azt a poz√≠ci√≥t hib√°nak tekintj√ºk.

P√©ld√°ul az F L F L F L mint√°n√°l:

p√°ros index≈± helyeken (0, 2, 4, ‚Ä¶) F-et v√°runk,

p√°ratlan index≈± helyeken (1, 3, 5, ‚Ä¶) L-t.

Ha a val√≥s sorban ett≈ël elt√©r√©s van, akkor n√∂velj√ºk a hibasz√°ml√°l√≥t az ‚ÄûF-lel kezd≈ë‚Äù mint√°ra. Ugyanezt k√ºl√∂n megsz√°moljuk az ‚ÄûL-lel kezd≈ë‚Äù mint√°ra is, ahol a p√°ros helyeken L-t, a p√°ratlanokon F-et v√°runk.

Nagyon fontos felismer√©s, hogy egy csere k√©t hib√°t jav√≠t ki egyszerre. Ha valahol rossz helyen √°ll egy F (fi√∫), m√°shol pedig rossz helyen √°ll egy L (l√°ny), √©s ezt a k√©t poz√≠ci√≥t felcser√©lj√ºk, akkor mindk√©t helyen j√≥ bet≈± lesz. Ez√©rt a sz√ºks√©ges cser√©k sz√°ma adott mint√°hoz:

cser√©k sz√°ma = hib√°k sz√°ma / 2

Ezt mindk√©t mint√°ra kisz√°moljuk:

hib√°k, ha F-lel kezd√ºnk ‚Üí cser√©k_F = hib√°k_F / 2

hib√°k, ha L-lel kezd√ºnk ‚Üí cser√©k_L = hib√°k_L / 2

A feladat megold√°sa a k√©t √©rt√©k k√∂z√ºl a kisebb.

Ez a m√≥dszer egyszer≈± mintafelismer√©sen √©s sz√°ml√°l√°son alapul, programoz√°s szempontj√°b√≥l is k√∂nnyen √©rthet≈ë, √©s j√≥l mutatja, hogyan lehet egy optimaliz√°l√°si probl√©m√°t nagyon egyszer≈± logik√°val megoldani.</pre>
        </section>

        <section class="block">
          <h3 class="label">Megold√°s (Java)</h3>
          <pre><code>import java.util.Scanner;

public class FiukLanyok {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt();
        sc.nextLine();

        String sor = sc.nextLine().trim();
        int hossz = sor.length();

        int hibakFKezzel = 0;
        int hibakLKezzel = 0;

        for (int i = 0; i &lt; hossz; i++) {
            char valos = sor.charAt(i);

            char vartFMinta;
            if (i % 2 == 0) {
                vartFMinta = 'F';
            } else {
                vartFMinta = 'L';
            }
            if (valos != vartFMinta) {
                hibakFKezzel++;
            }

            char vartLMinta;
            if (i % 2 == 0) {
                vartLMinta = 'L';
            } else {
                vartLMinta = 'F';
            }
            if (valos != vartLMinta) {
                hibakLKezzel++;
            }
        }

        int cserekF = hibakFKezzel / 2;
        int cserekL = hibakLKezzel / 2;

        int eredmeny = Math.min(cserekF, cserekL);

        System.out.println(eredmeny);
    }
}</code></pre>
        </section>

        <section class="block">
          <h3 class="label">K√©sz k√≥d (ZIP)</h3>
          <a class="btn download" href="zip/FiukLanyok.zip" download>‚¨á Let√∂lt√©s (feladat2-kod.zip)</a>
        </section>
      </article>

      <!-- 3. T√°rsasj√°t√©k ‚Äî Gr√°falgoritmus -->
      <article class="card">
        <div class="card-head">
          <h2 class="task-title"><span class="num">3</span> Beadand√≥ ‚Äî T√°rsasj√°t√©k</h2>
        </div>
        <div class="topic">
          <span class="chip graf">Gr√°falgoritmus</span>
        </div>

        <section class="block">
          <h3 class="label">Forr√°sfeladat</h3>
          <p class="line">
            üîó <a href="http://tehetseg.inf.elte.hu/nemes-online/2022/nemeso1-22.pdf" target="_blank" rel="noopener">
              Nemes Online 2022 ‚Äî 1. fordul√≥ (PDF)
            </a>
          </p>
        </section>

        <section class="block">
          <h3 class="label">Feladatsz√∂veg k√©pe</h3>
          <figure class="problem-fig">
            <img src="img/Tarsasjatek.png" alt="T√°rsasj√°t√©k ‚Äì feladatsz√∂veg" class="problem-img">
            <figcaption>T√°rsasj√°t√©k ‚Äî feladatsz√∂veg</figcaption>
          </figure>
        </section>

        <!-- T√ÅRSASJ√ÅT√âK ‚Äì MAGYAR√ÅZAT -->
        <section class="block">
          <h3 class="label">Magyar√°zat (sz√∂vegben)</h3>
          <pre class="explain">T√°rsasj√°t√©k ‚Äì Magyar√°zat (Gr√°f)

A feladatban egy t√°rsasj√°t√©k mez≈ëin kell v√©gighaladni. A mez≈ëk 1-t≈ël N-ig vannak sz√°mozva, √©s mindig az 1. mez≈ër≈ël indulunk. Minden mez≈ër≈ël k√©tf√©lek√©ppen lehet tov√°bbl√©pni:

‚Ä¢ sima l√©p√©ssel a k√∂vetkez≈ë mez≈ëre (i ‚Üí i+1),
‚Ä¢ vagy arra a mez≈ëre, amelynek a sz√°ma r√° van √≠rva az adott mez≈ëre.

Csak el≈ëre lehet l√©pni, vagyis az ugr√°s akkor haszn√°lhat√≥, ha nagyobb sorsz√°m√∫ mez≈ëre visz. Minden l√©p√©s egy l√©p√©snek sz√°m√≠t, teh√°t azt kell meghat√°rozni, mi a legkevesebb l√©p√©s, amellyel eljuthatunk az utols√≥ mez≈ëre.

A gondolkod√°som √∫gy n√©zett ki, hogy a mez≈ëket csom√≥pontoknak tekintettem. Minden mez≈ëb≈ël kimegy k√©t ‚Äû√∫tvonal‚Äù: az egyikkel egyet lehet el≈ërel√©pni, a m√°sikkal messzebbre lehet ugrani. √çgy a mez≈ëk egy egyszer≈± ir√°ny√≠tott gr√°fot alkotnak. A c√©l, hogy a lehet≈ë legr√∂videbb √∫tvonalat tal√°ljuk meg 1-t≈ël N-ig.

Ehhez vezettem egy t√∂mb√∂t, amelyben azt t√°roltam, hogy az adott mez≈ët h√°ny l√©p√©sb≈ël lehet el√©rni. Az indul√≥ mez≈ë √©rt√©ke 0, a t√∂bbi mez≈ë kezdetben nagyon nagy sz√°m. Ezut√°n sorban, balr√≥l jobbra v√©gighaladtam a mez≈ëk√∂n. Minden mez≈ën√©l megvizsg√°ltam, hogy ha el≈ërel√©pn√©k vagy ugran√©k, az kevesebb l√©p√©st jelent-e az adott c√©lmez≈ënek. Ha igen, akkor azt √°t√≠rtam. A folyamat v√©g√©n az utols√≥ mez≈ëh√∂z tartoz√≥ √©rt√©k adja a legr√∂videbb l√©p√©ssz√°mot.

A mez≈ëk gr√°fcsom√≥pontoknak tekinthet≈ëk. Minden cs√∫csb√≥l k√©t √©l indul: az egyik a k√∂vetkez≈ë mez≈ëre mutat, a m√°sik a mez≈ëre √≠rt c√©lmez≈ëre, ha az el≈ëre visz. Mivel minden √©l el≈ëre mutat, a gr√°f k√∂rmentes, √©s √≠gy egyszer≈± v√©gighalad√°ssal megtal√°lhat√≥ a legr√∂videbb √∫t. A m√≥dszer hasonl√≥ elven m≈±k√∂dik, mint a BFS, de a speci√°lis szerkezet miatt nincs sz√ºks√©g k√ºl√∂n sorra vagy √∂sszetett adatszerkezetre.</pre>
        </section>

        <section class="block">
          <h3 class="label">Megold√°s (Java)</h3>
          <pre><code>import java.util.Scanner;

public class Tarsasjatek {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt();
        int[] ugras = new int[n + 1];

        for (int i = 1; i &lt;= n; i++) {
            ugras[i] = sc.nextInt();
        }

        int nagy = Integer.MAX_VALUE / 2;
        int[] min = new int[n + 1];

        for (int i = 1; i &lt;= n; i++) {
            min[i] = nagy;
        }
        min[1] = 0;

        for (int i = 1; i &lt; n; i++) {
            if (min[i] == nagy) continue;

      
            if (min[i] + 1 &lt; min[i + 1]) {
                min[i + 1] = min[i] + 1;
            }

            int cel = ugras[i];
            if (cel &gt; i &amp;&amp; cel &lt;= n) {
                if (min[i] + 1 &lt; min[cel]) {
                    min[cel] = min[i] + 1;
                }
            }
        }

        System.out.println(min[n]);
    }
}</code></pre>
        </section>

        <section class="block">
          <h3 class="label">K√©sz k√≥d (ZIP)</h3>
          <a class="btn download" href="zip/Tarsasjatek.zip" download>‚¨á Let√∂lt√©s (feladat3-kod.zip)</a>
        </section>
      </article>

      <!-- 4. F√∂ldv√°s√°rl√°s ‚Äî Dinamikus programoz√°s -->
      <article class="card">
        <div class="card-head">
          <h2 class="task-title"><span class="num">4</span> Beadand√≥ ‚Äî F√∂ldv√°s√°rl√°s</h2>
        </div>
        <div class="topic">
          <span class="chip dp">Dinamikus programoz√°s</span>
        </div>

        <section class="block">
          <h3 class="label">Forr√°sfeladat</h3>
          <p class="line">
            üîó <a href="http://tehetseg.inf.elte.hu/nemes-online/2022/nemeso1-22.pdf" target="_blank" rel="noopener">
              Nemes Online 2022 ‚Äî 1. fordul√≥ (PDF)
            </a>
          </p>
        </section>

        <section class="block">
          <h3 class="label">Feladatsz√∂veg k√©pe</h3>
          <figure class="problem-fig">
            <img src="img/Foldvasarlas.png" alt="F√∂ldv√°s√°rl√°s ‚Äì feladatsz√∂veg" class="problem-img">
            <figcaption>F√∂ldv√°s√°rl√°s ‚Äî feladatsz√∂veg</figcaption>
          </figure>
        </section>

        <!-- F√ñLDV√ÅS√ÅRL√ÅS ‚Äì MAGYAR√ÅZAT -->
        <section class="block">
          <h3 class="label">Magyar√°zat (sz√∂vegben)</h3>
          <pre class="explain">F√∂ldv√°s√°rl√°s ‚Äì Magyar√°zat (dinamikus programoz√°s)

A feladatban egym√°s mellett sorban √°ll√≥ telkeket kapunk. Minden teleknek van egy √°ra. Tudjuk, hogy pontosan K db egym√°s melletti telket kell megvenn√ºnk egy sz√°llod√°hoz.

C√©l: meg kell tal√°lni

‚Ä¢ mennyi a legkisebb √∂sszeg, amit K szomsz√©dos telek√©rt fizetn√ºnk kell,
‚Ä¢ √©s hogy h√°ny k√ºl√∂nb√∂z≈ë K hossz√∫ szomsz√©dos telekcsoport adja ezt a minim√°lis √∂sszeget.

P√©lda a feladatb√≥l:

Bemenet
8 3
9 6 1 7 1 6 2 9

Itt 8 telek van, √©s mindig 3 egym√°s mellettit kell venni.

A lehets√©ges 3-as csoportok √∂sszegei:

1‚Äì3. telkek: 9 + 6 + 1 = 16
2‚Äì4. telkek: 6 + 1 + 7 = 14
3‚Äì5. telkek: 1 + 7 + 1 = 9
4‚Äì6. telkek: 7 + 1 + 6 = 14
5‚Äì7. telkek: 1 + 6 + 2 = 9
6‚Äì8. telkek: 6 + 2 + 9 = 17

A legkisebb √∂sszeg 9, √©s ezt k√©tf√©lek√©ppen kapjuk meg (3‚Äì5. √©s 5‚Äì7. telkek).

Kimenet teh√°t:
9
2

√ñtlet

Ha minden csoportot k√ºl√∂n-k√ºl√∂n kisz√°moln√°nk null√°r√≥l, az lassabb lenne. Dinamikus gondolkod√°ssal ink√°bb azt csin√°ljuk, hogy:

‚Ä¢ el≈ësz√∂r kisz√°moljuk az els≈ë K telek √∂sszeg√©t,
‚Ä¢ ut√°na mindig csak ‚Äûcs√∫sztatjuk az ablakot‚Äù egyet jobbra:
  ‚Äì kivonjuk az el≈ëz≈ë ablak bal sz√©ls≈ë telk√©nek √°r√°t,
  ‚Äì hozz√°adjuk az √∫jonnan bel√©p≈ë telek √°r√°t.

√çgy minden √∫j ablak √∂sszeg√©t az el≈ëz≈ë ablakb√≥l sz√°moljuk ki, egyetlen kivon√°ssal √©s egyetlen √∂sszead√°ssal. Ez egy nagyon egyszer≈± dinamikus programoz√°s jelleg≈± strat√©gia: az √∫j √°llapot az el≈ëz≈ë √°llapotb√≥l k√©sz√ºl.

Mik√∂zben v√©gig cs√∫sztatjuk az ablakot, folyamatosan figyelj√ºk:

‚Ä¢ mi a legkisebb eddigi √∂sszeg,
‚Ä¢ h√°nyszor fordult el≈ë ez a legkisebb √∂sszeg.

Megjegyz√©s: az aktu√°lis√ñsszeg lehet nagy, ez√©rt a Java-ban long t√≠pust haszn√°lok r√°, hogy biztosan ne fusson t√∫l.</pre>
        </section>

        <section class="block">
          <h3 class="label">Megold√°s (Java)</h3>
          <pre><code>import java.util.Scanner;

public class FoldVasarlas {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt();
        int k = sc.nextInt();

        int[] telkekAra = new int[n];
        for (int i = 0; i &lt; n; i++) {
            telkekAra[i] = sc.nextInt();
        }

        long aktualisOsszeg = 0;
        for (int i = 0; i &lt; k; i++) {
            aktualisOsszeg += telkekAra[i];
        }

        long legkisebbOsszeg = aktualisOsszeg;
        long darab = 1;

        for (int i = k; i &lt; n; i++) {
            aktualisOsszeg -= telkekAra[i - k];
            aktualisOsszeg += telkekAra[i];

            if (aktualisOsszeg &lt; legkisebbOsszeg) {
                legkisebbOsszeg = aktualisOsszeg;
                darab = 1;
            } else if (aktualisOsszeg == legkisebbOsszeg) {
                darab++;
            }
        }

        System.out.println(legkisebbOsszeg);
        System.out.println(darab);
    }
}</code></pre>
        </section>

        <section class="block">
          <h3 class="label">K√©sz k√≥d (ZIP)</h3>
          <a class="btn download" href="zip/Foldvasarlas.zip" download>‚¨á Let√∂lt√©s (feladat4-kod.zip)</a>
        </section>
      </article>

    </section>

    <p class="footnote">Makra-Szab√≥ Csilla 2025</p>
  </main>
</body>
</html>
